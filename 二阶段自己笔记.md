### let:它是用来定义变量的关键字(和var具备同样的功能)

  1.let定义的变量必须先定义后使用

  console.log(a);

  let a = 123;



 2.在同一作用域下,let修饰的变量不能重复定义

 let a = 123;

 let a = 456;



 3.暂时性死区，当内部变量与外部变量同名时,内部变量屏蔽外部变量

  let a = 123; {

 let a = 456;

   console.log(a);

}

 console.log(a);



4.块级作用域:在当前作用域内的数值不会消失

  var oLis = document.getElementsByTagName("li");

 for (var i = 0; i < oLis.length; i++) {

 oLis[i].index = i;

oLis[i].onclick = function() {

 console.log(this.index);

 }

}

  for (let i = 0; i < oLis.length; i++) {

​    oLis[i].onclick = function() {

​      console.log(i);

​    }

  }

### const:

被const修饰的变量称为只读变量(有名字的常量)

  const PI = 3.1415926;

  console.log(PI);



  2.被const修饰的变量必须初始化

  const A;//错误

  A = 1232;

  console.log(A);



  3.块级作用域

  4.暂时性死区

  5.不能重复定义

  6.先定义后使用



  习惯上只读变量名全都大写



  \---------------------------------------------------

  面试题:var,let,const的异同?

  1.都是用来修饰变量的

  2.var具备声明提升

  3.let4个特性

  4.const修饰的变量称为只读变量,必须初始化,其他4个特性,习惯上只读变量名全都大写

// this:函数体内的内置对象

  // a.当this出现在事件函数体时,this代表触发该事件的元素

  // document.onclick = function() {

  //   console.log(this);

  // }



  // var oBox = document.querySelector("div");

  // oBox.onclick = function() {

  //   console.log(this);

  // }



  // var oInput = document.querySelector("input");

  // oInput.onblur = function() {

  //   console.log(this.value);

  // }



  //b.与普通函数连用时(除了构造方法和事件体),代表调用该函数的对象本身

  // function fun() {

  //   console.log(this);//window

  // }



  // window.fun();



  // let stu = {

  //   "name": "豆文博",

  //   "showValue": function() {

  //     console.log(this.name);

  //   }

  // }



  // stu.showValue();



  //-------------------------------------------------------



### bind:

是函数对象的函数,改变函数的this指向,主要针对于匿名函数

  // 参数：bind（被修改的this指向）



  // var fun = function(){



  // }



  // fun == function(){}

  // fun.bind(参数) = function(){}.bind(参数)



  var oBox = document.querySelector("div");

  document.onclick = function() {

​    this.style.display = "none";

  }.bind(oBox);

### json：

对象和字符串:标准格式的json的key必须被双引号引起来

JSON对象转字符串

 let json = {

"name": "刘昊然",

"age": 88

};

##### JSON.stringify(json对象):返回json字符串

let str = JSON.stringify(json);

console.log(typeof str, str);



JSON字符串转对象

##### JSON.parse(json字符串): 返回json对象

let str1 = '{"name": "刘昊然","age": 88}';

let json1 = JSON.parse(str1);

console.log(json1);

#####  for...in 遍历下标 通常用来遍历json

let arr = [6, 5, 7, 8, 4, 9, 0, 3];



 for (let index in arr) {

console.log();

}



let json = {

"name": "刘昊然",

"age": 88

};



for (let index in json) {

console.log(index);

 }



  ------------------------------------------

##### for...of 遍历内容(针对于没有下标的容器,set和map后续章节讲解)

  let arr = [6, 5, 7, 8, 4, 9, 0, 3];

  for (let item of arr) {

​    console.log(item);

  }

##### str.includes(参数): 返回布尔值，表示是否找到了参数字符串。

##### str.startsWith(参数)：返回布尔值，参数是否在源字符串的头部。

##### str.endsWith(参数)： 返回布尔值，参数是否在源字符串的尾部。

  // let str = "jin tian bu da zhang le.txt";

  // console.log(str.includes("da1"));

  // console.log(str.startsWith("jin"));

  // console.log(str.endsWith(".txt"));



  //------------------------------------

  //生僻汉字的打印

  //ES6之前打印汉字的方式是utf-16

  // 0~65535

  // let str = "豆文博";

  // console.log(str.charAt(0));



  //21C56

  let str = "𡱖";

  // console.log(str.charAt(0));



  //打印字符

  console.log("\u{21C56}");

  //打印unicode码

  console.log(str.codePointAt(0).toString(16));

  // 箭头函数:匿名函数的另一种写法 

  // let fun = function() {

  //   console.log("今天星期四");

  // }

  // let fun = () => {

  //   console.log("今天星期四");

  // }

  // fun();



  // document.onclick = () => {

  //   console.log("嘤嘤嘤");

  // }

### 箭头函数的特性:

  // let fun = (a) => {

  //   return a + 5;

  // }

 1.如果匿名函数只有一个参数，则可以省略参数的小括号

  // let fun = a => {

  //   return a + 5;

  // }

  // console.log(fun(11));



2.如果匿名函数的函数体只有一条语句,则可以省略{}

  // let fun = a => console.log(a);

  // fun(11);



3.如果匿名函数的函数体只有一条语句,自带return

  // let fun = function(a){

  //   return a+5;

  // }

  let fun = a => a + 5;

  console.log(fun(20));

### 解构赋值:解析结构进行赋值

**1.按照容器格式初始化对象:强调等号左边和右边必须类型一致**

  // let x,y,z;

  // x = 1;

  // y = 2;

  // z = 3;

  // let [x, y, z] = [1, 2, 3];

  // console.log(x, y, z);



  // let {

  //   name,

  //   age

  // } = {

  //   name: "迪丽热巴",

  //   age: 30

  // };

  // console.log(name);

  // console.log(age);



  let json = {

​    name: "迪丽热巴",

​    age: 30

  }

**去掉json对象的前缀**

  let {

​    name,

​    age

  } = json;

  console.log(name);

  console.log(age);

**2.交换两个变量的值**

  let a = 1,

​    b = 2;

  [a, b] = [b, a];

  console.log(a, b);

### ES6模板字符串

  let oUl = document.querySelector("ul");

​    ``table上面那个符号,与双引号和单引号的区别,支持换行
​    oUl.innerHTML =
​        `<li class='test'>123</li>
​        <li>123</li>
​        <li>123</li>
​        <li>123</li>
​        <li>123</li>`;

​    let oDiv = document.querySelector("div");
​    oDiv.innerHTML = `        <span>佛跳墙</span>
​        <span>价格:<span>0</span></span>
​        <button class="btn">-</button>
​        <span>0</span>
​        <button class="btn">+</button>`;

​    for (let i = 0; i < 10; i++) {
​        //``的变量必须用${变量}
​        oUl.innerHTML += `<li>${i}</li>`;
​    }

### set:

**没有下标，自动去重**

  let s = new Set(数组);

  let s = new Set([1, 1, 2, 3, 4, 2, 3, 5, 7]);

  console.log(s);

 数组去重

  let arr = [1, 1, 2, 3, 4, 2, 3, 5, 7];

  let s = new Set(arr);

  console.log(s)

  ------------------------------from:将参数转换为数组-------------------------------

  arr = Array.from(s);

  console.log(arr);



  -------------------------------add(参数) 向集合中添加一个元素

  -------------------------------delete(值) 删除集合中某个数

  --------------------------------has(值) 判断集合中是否含有某个值

  ------------------------------------clear() 清空集合



  let s = new Set([1, 1, 2, 3, 4, 2, 3, 5, 7]);

  s.add(11);

  s.add(11);

  s.delete(1);

  console.log(s.has(2));

  s.clear();

  console.log(s);



  for (let item of s) {

​    console.log(item);

  }





  map: 映射，由若干个键值对构成的容器

  所有的操作都是用key来完成的



  set(key,value) 向集合中添加一个元素:key以存在，则为改，不存在则为增

  get(键)  根据键去取值

  delete(键) 删除集合中某个数

  has(键) 判断集合中是否含有某个值

  clear() 清空集合

### map: 映射，由若干个键值对构成的容器

所有的操作都是用key来完成的

set(key,value) 向集合中添加一个元素:key以存在，则为改，不存在则为增

 get(键)  根据键去取值

delete(键) 删除集合中某个数

 has(键) 判断集合中是否含有某个值

clear() 清空集合

  let m = new Map();

  m.set("A", "嘿嘿");

  m.set("B", {

​    "name": "laowang",

​    "age": 18

  });

  m.set("C", 123);

  m.set("C", 666);



  // console.log(m.get("A"));



  m.delete("B");



  console.log(m.has("sadfsadf"));



  // // m.clear();



  // // console.log(m);



  // for (let item of m) {

  //   console.log(item[0], item[1]);

  // }

 

### 一、面向过程和面向对象的差别

面向过程：强调过程，程序是一步一步执行的

程序=算法+语法

算法强调步骤



面向过程编程是缺陷的：

1.随着问题规模的增加，代码逐渐失控

2.复用性较差（只有函数）

面向对象：强调的是对象

程序=对象1+对象2+对象3+.....

并不是不在意过程，将视点放在对象上

对象：万物皆对象（将若干属性和方法封装至一个整体）



面向对象的三大特性：封装、继承、多态



### 二、类和对象

类：拥有相同属性和对象的集合（模板）

对象：是类的实例化（唯一性，且真实存在）



### 三、es5创建类

js本质没有类的概念

es5创建类的方式，通过函数模拟类

Student在这里代表类名，同时也代表一个构造函数



类的定义

function Student（name，age，tall）{

  //为new的对象添加自定义属性

  this.name=name;

  this.age=age;

  this.tall;

  //类的成员方法访问其他的成员属性或方法

  this.eat=function(){

​    console.log(this.name+":eat");

  }

  this.coding=function(){

​    console.log(this.name+":coding");

  }



}

//对象的创建

let s=new Student("老王"，8,1.3)；

//对象中属性和方法的使用

console.log(s.name,s.age,s.tall);

s.eat();

s.coding();



//对比引用类型

let arr=new Arry(1,2,3);

arr.pop();

**------------------------------------**

### this的作用

1.与事件连用，代表触发该事件的元素

2.与函数连用，代表调用该函数的对象

  function fun() {

  //   console.log(this);//window

  // }



  // window.fun(); 

3.与构造方法连用，代表new出来的对象



### 四、es6构造方法创建类

class 类名{

  //构造方法，构造属性

  constructor（）{}

  其他成员方法

}

//语法糖



class Student{

  //构造方法

  constructor(name,age,gender){

​    this.name=name;

​    this.age=age;

​    this.gender=gender;

  }

  //普通方法

  eat(){

​    console.log(this.name+":eat");

  }

  coding(){

​    console.log(this.name +":coding");

  }

}

let s1=new Student("老王"，8，"m");

console.log(s1.name,s1.age,s1.gender);

s1.eat();

s1.coding();



//面试题：

构造方法和普通方法的区别

1.构造方法必须和new关键字连用

2.构造方法名习惯上首字母大写

3.构造方法中不能写return



### 五、类与类的关系组合

组合：一个类的某个属性，是另一个类型的对象



class Birthday{

  constructor(y,m,d){

​    this.y=y;

​    this.m=m;

​    this.d=d;

  }

  showValue(){

​    console.log(this.y,this.m,this.d);

  }

}

class Sudent{

  construcor(name,age,bir){

​    this.name=name;

​    this.age=age;

​    this.bir=bir;

  }

  showValue(){

​    console.log(this.name,this.age);

​    this.bir.showValue();

  }

}

let bir=new Birthday(2022,1,15);

let s=new Student("老王"，18，bir);

s.showValue();



### 六、类与类的关系依赖

依赖：一个类的函数参数是另一个类的对象

class Road{

  constructor(length){

​    this.length=length;

  }

}

class Car{

  constructor(speed){

​    this.speed=speed;

  }

  time(r){

​    //一个类的函数参数是另一个类的对象

​    return r.length/this.speed;

  }

}

let r=new Road(1000);

let c=new Car(60);

console.log(c.time(r));



六、小明的问题

// 小明  :  手  交换 看牌

// 小明的左手  小明的右手 : 牌

// 红桃A  黑桃K : 数字和花色

class Poker{

  constructor(num,color){

​    this.num=num;

​    this.color=color;

  }

}

class Hand{

   constructor(poker){

​    this.nupokerm=poker;

  }

}

class Person{

   constructor(lh,rh){

​    this.lh=lh;

​    this.rh=rh;

  }

  showPoker(){

​    console.log(this.lh.poker.num,this.rh.poker.num)

​    console.log(this.lh.poker.color,this.rh.poker.color)

  }

  swap(){

​    [this.lh.poker,this.rh.poker]=[this.rh.poker,this.lh.poker]

  }

}

let p1=new Poker("A","♠")

let p2=new Poker("B","♥")

let lh=new Hand(p1);

let rh=new Hand(p2);

let p=new Person(lh,rh);

p.showPoker();

p.swap();

p.showPoker();