## **一、php与mysql**

### 1.服务器

js的编译环镜是浏览器，php的是apache，8848是hbuilder自带的服务器

服务器概念：一台电脑运行了一个非凡的环境(软件)，在这个环境中，会将电脑上一个磁盘空间(文件夹)对外开放，当外界电脑找到这个电脑时，能够拜访这个磁盘空间里面的内容，当这个电脑始终运行，始终能够被拜访，就是一个服务器，装有PHP study环境的电脑就是一个服务器。

服务 ：在这个磁盘空间中对访问者提供不同需要的数据；

web服务器：一般指的是网站服务器，也就是我们打开的各种网站的数据来源，它实际上是服务器上运行的程序，这个程序通过HTTP协议与浏览器等客户端进行通信，可以处理浏览器等web客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览，可以放置数据文件，让全世界下载把网页展现给用户，也称为www服务器，主要功能是提供网上信息浏览服务apache，Nginx,IIS就是web服务器（可以通过外网访问web服务器文件）

数据库服务器：提供数据，处理数据增删改查

web服务器的工作原理（B/S）:

a:打开浏览器地址栏输入地址，浏览器通过http协议向服务器发起get(获取)请求

b:服务器收到请求后，解析url,找到对应文件,根据url中的参数和对应文件生成html文件，将生成的文件返回给浏览器，

c:浏览器收到服务器返回的响应后，按照规则对HTML进行解释编译，并显示为网页

phpstudy:php的运行环境，它实际上提供了许多其他语言的服务，www是服务器的目录，带有www路径相当于ip地址，在别人访问时，等价于本机访问，当登录客户端时第一个看见的就是这个目录以及他的子目录

当服务器接收到请求时，如果请求的是单纯的HTML页面，服务器（比如Apache）会直接把这个页面返回给请求。如果是PHP页面，服务器（比如Apache）会识别php页面中的php标签，并调用PHP模块来执行PHP文件，执行完后，将结果返回给请求。

两种表现形式：C/S[客户端与服务器]，需要安装软件、B/S[浏览器端与服务器]，不需要软件：过程：浏览器向服务器发送请求，服务器接受请求进行解析向浏览器响应，浏览器接受响应，进行解析并生成页面。

2.php特点：服务器端语言、跨平台、开源软件；缺点：解释执行，边编译边执行与js一样；

3.php的环境搭建：PHP study；将php需要的代码要放在www的目录下(服务器的目录)；

4.用服务器打开页面：在浏览器中输入：http://ip地址：端口/文件名

**环形地址：代表本机ip，localhost||127.0.0.1;**

5.php的编码格式：中文问题：header("Content-type:text/html;charset=utf-8");

6.php语法：

格式：;

定义变量名$符开头，变量名区分大小写；

php的变量的数据类型是由运行时的上下文决定的:例如：$a=90;$b="hello";

字符串的连接：php中用**.**表示;

流程控制：顺序语句（自上而下，从左到右），分支语句（if，switch），循环语句（for）；

php的函数：function add($a,$b){};

php的数组，用count($arr)来获取arr的长度；

7.php接受前端的数据

$_POST['参数名']

$_GET[''参数名]

$REQUEST['参数名'];两种都行

;服务器：拥有服务器软件的pc；

注释：//、#、/**/

php文件必须通过web服务器apache进行访问，

访问方式：ip加文件名

www之前的路径（包含www）等价于ip

php的后缀为.php

php文件的功能：类似于html，用来处理后端

php文件必须加分号；

###   二、数据库

1.库-->表-->字段-->记录，

2.数据库是按照数据结构来组织，存储，和管理数据的仓库；

3.int--》整形；varchar[可变长]/char[固定长]--->字符串，date--->日期；

4.常见的数据库类型：关系型数据库，非关系型数据库；

5.语法：

创建数据库：create  database 数据库名；

创建表：create table 表名（字段1   数据类型，字段2    数据类型，字段3    数据类型......）；

sql语句：增删改查；

insert into 表名(字段1，字段2，字段3)values(1,2,3)||insert into 表名values();

delete from 表名 where  条件；

delete from 表名；内容全部删除，表还在，

drop table 表名；直接删除表

**where类似于if,and类似于&&，or类似于||；**

update 表名 set 字段1=值1，字段2=值2；

update 表名 set 字段1=值1，字段2=值2 where  条件；

select 字段1from 表名；

in ：存在

not in:不存在；

between.....and():包含 

order by 属性 ASC(升序)||DESC(降序);

字符串类型得带长度

6.php连接mysql:

步骤：

​	1.登录数据库,创建连接对象(登录后有一个用户)

​	//$conn = mysql_connect("数据库服务器的地址","用户名","密码"):返回值为连接对象

​	$conn = mysql_connect("localhost","root","root")

​	if($conn){

​		echo "连接成功";

​		2.选择数据库

​		mysql_select_db("2105");

​		3.对数据库进行操作:增删查改

​		//mysql_query(sql语句,连接对象);

​		mysql_query("insert into student values (6,'超哥',9)",$conn)

​		4.关闭连接对象

​		mysql_close($conn);

​	}

?>

对数据库的操作：

增删改(dml),

查(dql):

$result = mysql_query("select * from student",$conn);===>返回值为结果集；

$rows = mysql_num_rows(结果集):返回结果集拥有的记录数；

mysql_fetch_assoc(结果集):返回当前游标所指向的记录,以对象的方式返回，每当执行一次该函数,游标自动下移；

**6.模糊查询：**SELECT 字段 FROM 表 WHERE 某字段 Like 条件；

% ：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。

_ ： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句：

[ ] ：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。

   	[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符外的任以一个字符。

### 三.cookie与http

1.）http:（超文本传输协议),是一个基于请求与响应的应用层协议；

标准的url：请求资源的地址；http://ip地址：端口号/文件路径；其中端口指定了软件，比如**80：php的端口，8848：hbuilder的端口，3306：mysql的端口**

**过程：ip地址访问到电脑主机，端口号选择相应的服务器进入www目录，加文件名**

请求方式：get传输数据量小，不安全，效率高（多用于查询）

post:传输数据量大，安全，效率低

常见的响应状态码

**200 OK    //客户端请求成功**

**400 Bad Request //客户端请求有语法错误，不能被服务器所理解**

**401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用**

**403 Forbidden //服务器收到请求，但是拒绝提供服务**

**404 Not Found //请求资源不存在，输入了错误的URL**

**500 Internal Server Error //服务器发生不可预期的错误**

**503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常**

**2）.cookie**

**1.cookie:**会话跟踪技术：是存储于访问者的计算机中的变量，当浏览器与服务器之间发生多次请求时，数据共享的过程，被称为会话跟踪技术，而共享的数据被称为cookie，具有页面之间传递数据的作用，每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie，用户访问二级页面时会自动判断上个页面是否存在cookie，若存在自动带入下一级页面，cookie的使用与服务器有关，否则无法保存，可以使用 JavaScript 来创建和取回 cookie 的值。可以将用户的登录名密码存储于cookie中，实现自动登录功能，也可以用来保存购物车信息。

原理：当cookie是会话级别的时， cookie是服务器保存在用户内存上的字符串文件，他可以包含有关用户的信息当是长生命周期时，所有的cookie都 存放在硬盘里，但是每个网站对应相应的cookie，开始请求时如果没有服务器，不会执行cookie语句，因为不是cookie的运行环境，当有了服务器时，客户端访问服务器，服务器生成cookie,在响应头中发给客户端，客户端保存在硬盘里，

内存与硬盘的区别：计算机与硬盘进行交换数据，而内存作为硬盘与计算机之间的桥梁，硬盘先从将数据传到内存，内存再与计算机进行交互，内存里面的数据容易丢失，但运行速度很快。

1. 用户 linuxmooc 登陆 baidu
2. baidu 服务端会生成一个用户 ID
3. 然后，服务端将这个用户 ID 发送给浏览器
4. 浏览器收到这个用户 ID 后，会将这个用户ID保存在用户本地终端
5. 浏览器再次访问 baidu 站点时，浏览器会将保存在本地的用户ID再次发给 baidu 服务端

服务端收到浏览器发送的用户 ID 后，就知道此次请求来自于一个已经登陆的用户。在以上的交互过程中，保存在客户端的用户 ID 就被称为 cookie

作用：页面之间的数据传递;概念： 浏览器（B端）和服务器 之间在进行多次请求数据时【页请求】，数据共享的过程 就称为 会话跟踪技术；【如果出现页面时，就必定是浏览器向服务器发送请求，服务器经过解析之类的出现你需要的页面，所以称为请求】

生存周期：cookie数据在浏览器上保存的时间;分为两种：

会话session：用户进入网站 开始浏览到结束浏览的这样的一个过程 就称为一次会话 ； 

长生命周期：document.cookie = "键=值;expires="+标准时间格式"(let date = new Date(); date.setDate(date.getDate()+day));

2.cookie数据的存和取：（一行只能写一个cookie）

document.cookie = "键=值" 存；【有就是改，没有就是存】

document.cookie      取；

获取值的步骤：

​    let strCookie = document.cookie；

​    let arrCookie = strCookie.split("; ");//注意这一步贼关键分号+空格

​    for(let t in arrCookie){

​      let item = arrCookie[t].split("=");

​      console.log(item[0],item[1])；

3.cookie的删除：将键对应的值设为空，expires="-1"；

4.cookie的特点：

（1）cookie可能被禁用。

（2）cookie是与浏览器相关的。不同浏览器所保存的cookie也是不能互相访问的。

（3）cookie可能被用户删除。

（4）cookie安全性不够高。如果要保存用户名密码等信息时，最好事先经过加密处理。

（5）存储的数据量 4k 大小，cookie只支持存储string类型的数据。

（6）简单易用。

（7）信息存储于用户硬盘，因此可以作为全局变量。

5.cookie的封装：

6.cookie的使用必须有服务器，没有服务器保存不了

在本地访问下，cookie在chrome上设置无效，需要在服务器环境下才可以操作cookie（如：http://localhost本地服务器）! 原因在于chrome不支持js在本地操作cookie。

7.获取cookie:获取的数据为键值对字符串,

8.关闭页面时触发

​	 window.onbeforeunload = function(){

​	 let date = new Date();

​	 	date.setDate(date.getDate()+7);

​		document.cookie = "age=18;expires="+date;

​	 }

### 四.ajax==>XMLHttpRequest像服务器发送请求

（看场合使用）

**1.概念：****异步 JS 和 XML，是指一种创建异步交互式网页应用的网页开发技术，前端通过与服务器进行少量的数据交换，Ajax就可以使网页实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，传统的网页不使用Ajax，如果需要更新内容(需要发送请求，只有form；)，必须重载整个网页页面，而ajax不用，只进行局部更新**

2为什么要使用ajax；

在不中断用户操作的情况下与Web服务器进行通信；

更灵敏的响应用户访问，实现近似于桌面应用程序的交互效果；

通过局部更新内容降低网络流量，提高网络的使用效率；无需重新加载整个网页，就能够更新部分网页；form需要加载整个页面；

更流畅的用户体验，对用户的操作即时响应

3.同步：按照代码行一步接一步的执行;(在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。

)

4.异步：当遇到需要等待或者消耗时间的代码,则跳过该任务先去执行后续任务, 直至异步代码消耗完时间,再次执行;(执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。

)

异步代码的分类: a.定时器b.事件体 c.发送请求接收响应【送信】

​	  document.onclick = function(){//同步

​		    console.log("heihei");//异步【页面渲染完才执行事件体】

​	    }

当同步代码和异步代码同事出现时，先同步后异步，异步不遵循执行顺序，谁的时间先消耗完执行

5.任务可以分为两种，同步任务与异步任务.(同步任务[执行栈]指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；

异步任务[任务队列]指的是，不进入主线程、而进入"任务队列"的任务，只有等主线程任务执行完毕， "任务队列"开始通知主线程，请求执行任务，该任务才会进入主线程执行。

)

6.xmlhttpRequest对象：AJAX的核心对象是XMLHttpRequest，即AJAX的异步操作，和服务器 交互主要依赖该对象。 XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力

特点：拥有ajax所有的属性与方法，打点就可使用；可以让浏览器只负责显示，而完成请求的事情由XMLHttpRequest对象负责，用户永远不会看到浏览器空白。

7.ajax的编写步骤：

[掏手机]1、创建XMLHttpRequest对象： let request = new XMLHttpRequest();

[拨号]2、设置请求参数：

open:

功能：设置传参类型，请求地址和参数

get:参数：open(请求类型，url?参数，是否异步)

post:xhr.open("post","2ajaxPost.php",true);

 request.open("get", "服务器地址", true||false); true代表异步

**url有两种写法：一种是包含协议主机地址端口号文件名的绝对地址，一种是相对于当前请求地址的相对路径，只有文件名**

[发送]4、发送请求

send:

功能：对get传参而言，只是发送参数功能，无参: request.send();

对post传参，需要传递参数，有参：步骤：

​		//1.设置请求头,将参数以form表单post的方式发送

​		xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");

​		//2.参数在send中传递

​		//key1=value1&&key2=value2...

​		xhr.send("userName="+this.value);

[等待]3、设置回调函数

onreadystatechange:该事件是由readystate状态码发生改变而被触发

readystate2,3,4都会触发onreadystatechange

  request.onrteadystaechange = function(){

 if(request.readyState == 4&&request.status==200) {

 fun(request.responseText);

 }

   }

function fun(responseText){

前后端分离

}

[回馈]5、接收响应

 request.responseText或者request.responseXML：是返回来的数据；

8.XMLHttpRequest的属性与状态码

onreadystatechange:每次对象状态改变所触发事件的事件处理程序

readyState:对象状态码：

​       0 = 未初始化（uninitialized）对象创建完毕就是0

​       1 = 正在加载（loading） 1：对象设置完成后就是1.即调用open函数后，装载，准备工作

​       2 = 加载完毕（loaded） 调用send函数后，变成2，因为，只要调用send说明加载完毕

​       3 = 交互（interactive）到服务端了

​       4 = 完成（complete） 服务器端处理完毕了

responseText:从服务器进程返回的数据的字符串形式（服务器返回给前端的信息）

status:   从服务器返回的数字代码，如404（未找到网址写错）或200（就绪）500服务器问题【响应状态码】

9.//接口:与后端交互的标准//url:请求地址、//参数:请求参数、//返回数据:数据格式

10.后端(php)传递的是json类型的字符串时：//返回json对象有两种方法

​	//1.返回json字符串//echo '{"name":"高少鑫","age":18}'

​	//2.通用php返回json数组:$arr = ["name"=>"高少鑫","age"=>19];

​								//将数组转换为json字符串

​								echo json_encode($arr);

前端获取并处理：let json = JSON.parse(resText);将字符串转为json对象再处理

oninput:只要有输入的行为就触发事件

echo,有两个作用，一是等价于document.writer,二是在ajax里面，他的返回值是由echo带回的，如果出现多个echo，会自动拼接成字符串返回，

**11.ajax的封装思想：**

**功能:发送请求,接收响应,**

​	 **参数:**

​	**type:get还是post,**

​	 **url:服务器地址,**

​	 **isAsyn:是否异步,**

​	 **data:key1=value1&key2=value2****,[字符串型]**

​	 **callBack:用来接收responseText**

### 五.Promise

[Es6的语法规则]

1.概念：Promise是一个构造方法，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，从他的实例对象可以获取异步操作的消息，promise能解决回调地域问题，将函数的嵌套调用转为平级调用，改变了回调函数的传参方式，实现了多个函数的嵌套调用，通常将promise对象放入函数体内，作为函数的返回值，通过调用类的then方法传入回调函数并执行，promise有三种状态pending，success，faild,

2.作用：解决回调地狱问题，将函数的嵌套调用变为平级调用（改变回调函数传参的方式），Promise实现多个回调函数的嵌套调用

3.语法：

1）promise对象通常放入一个函数体内

​	   2）promise会作为该函数的返回值return p;

​	   3）在该函数调用结束后,通过then方法传入回调函数 

示例：function fun(){

​		let p = new Promise(function(f1,f2){

​			f2();

});

​		return p;

​	}

function f2(){

​		console.log("f2");

​		let p = new Promise(function(f){

​		f();

​	});

​		return p;

}

function f3(){

​		console.log("f3")

}

fun().then(f1,f2).then(f3);======promise对象.then(f1,f2)

4.Promise缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消。

不设置回调函数，Promise内部抛出的错误，不会反应到外部。

当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

注意事项:

​	promise实际操作中,回调函数一定运行的是异步代码

​	promise回调函数的两个参数:

​	发送请求,接收响应

​	参数1:代表成功时执行的代码,

​	参数2:代表失败时执行的代码

异步操作：ajax,事件体，定时器，请求与响应，

\1. all处理多个请求，最终返回所有的响应结果, 必须所有的请求都结束后，才会整体返回响应

,所有的响应内容放置一个数组中,当所有事件执行完才输出结果，结果都放置在一个数组里，只有全部成功才会输出，否则失败

let p1=new Promise(function(success){

​		success("1");

​	});

let p2=new Promise(function(success){

​		success("2");

​	});

let p3=new Promise(function(success){

​		success("3");

​	});

Promise.all([p1,p2,p3]).then(function(result){console.log(result)});

2.race:谁快就先执行谁

 Promise.race([p1, p2, p3]).then(result => console.log(result));

### 六.跨域访问jsonp：

//接口

​	//url:http://suggestion.baidu.com/su?参数:wd=关键字&cb=回调函数名

​	//参数:wd=关键字&cb=回调函数名

​	//返回数据的格式:json对象

【直接按照后端给的接口格式给值就行，不用纠结后端怎么得到】

1.概念：跨域名访问,A网站的网页在代码里访问b网站，通常情况下，受到同源策略(IP地址，端口，协议都要要相同)的限制，不同网站之间不能访问，JavaScript或Cookie只能访问同域名下的内容，为了打破这种限制，我们可以通过jsonp来达到目的，实现跨域访问

2.jsonp:一种跨域的技巧,本质上是利用HTML中src属性都可以跨域访问任何网站文件的特点

3.语法：

JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。

4跨域访问的步骤

​	1.前后端约定函数名

​	 2.前端写函数定义

​	 3.后端写函数调用

​	 4.前端通过script的src文件引入后端所传递的数据,实现跨域访问

注意事项：AJAX不支持跨域访问，

\* 面试题：请问jsonp是不是ajax中实现跨域访问的技术

jsonp不是AJAX中实现跨域访问的技术

1、jsonp没有使用XMLHttpRequest对象。

2、jsonp只是在一种跨域的技巧。

3、jsonp只支持Get方式

由于按照jsonp的这种方式跨域访问时，好像可以利用javascript和服务器端交互，能达到AJAX中XMLHttpRequest对象同样的效果。所以，人们总是把jsonp和AJAX联系在一起。

\* 面试题：jsonp和json的区别？

1、jsonp和json根本就没有关系

2、jsonp是跨域访问的技巧

3、json是描述数据的格式

CORS:跨域资源共享，允许所有域名访问，直接在请求的页面上加：header("Access-Control-Allow-Origin:*");

### 七.bootstrap[栅格布局]

1.原理：网格系统的实现原理非常简单，通过定义容器大小，平分12份(也有平分成24份或32份，但12份是最常见的)，再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统。Bootstrap框架中的网格系统就是将容器平分成12份。

在使用的时候大家可以根据实际情况重新编译LESS（或Sass）源码来修改12这个数值（也就是换成24或32，当然你也可以分成更多，但不建议这样使用）。

使用规则:

1 行(.row)必须包含在容器（.container）中，以便为其赋予合适的对齐方式和内距(padding)。

2 在行(.row)中可以添加列(.column)，最多分配12。

3 具体内容应当放置在列容器（column）之内，而且只有列（column）才可以作为行容器(.row)的直接子元素

4 类似 .row 和 .col-sm-4 这种预定义的类，可以用来快速创建栅格布局。

5 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔

 

 

为了确保适当的绘制和触屏缩放， 需要在中添加viewport元数据标签

width=device-width      宽度等于设备宽度

initial-scale=1.0      初始显示大小——原始大小，即不进行缩放

 

### 八.面试点

1.匿名函数

概念:没有名字的函数，即关键字function后面没有标识符

写法：function(){}

用法：

  \* 函数表达式（var test = function(){}）

  \* 事件处理函数 (window.onload = funciont(){})

  \* 自运行（立即执行）

  \* 闭包里的返回值 

2.函数的使用方法：

方法一：定义一个函数，把函数名赋给 onload属性

function test(){ alert("亲1");}；window.onload=test;

方法二：定义一个匿名函数，直接赋给 onload属性

window.onload = function(){ alert("亲2");}

方法三：定义一个匿名函数赋给一个变量；然后把变量赋给onload事件属性； 比写法二多了个中间变量而已

var test = function(){  alert("亲3");}；window.onload = test;

方法四：定义一个匿名函数赋给一个变量，用变量（当作函数名）来调用函数；

var test = function(){alert("亲4");}test();

结论：函数可以赋给一个变量，其实函数是个对象，因此，函数名作为另外一个函数的参数:

3.自运行：针对于匿名函数,当一个函数定义时直接运行(调用)

概念：自己运行自己的函数，不用别人调用(学习闭包)

语法：形式1：用()将整个函数代码块括起来

 (function(){  console.log("123");  }());

形式2：.将函数对象用(括起来)：

(function(){alert(“亲”);})()；

形式3. 通过关键字或者运算符实现自运行

 ！function fun (){alert(“亲”);}（）

void  function fun (){alert(“亲”);} ()；

自运行只执行一次，第二次为将第一次运行的结果赋值

4.闭包:

概念:函数嵌套函数,被嵌套的函数称为闭包函数,为了能在函数外部使用函数内部变量，利用了作用域链中子函数可以访问父函数的变量的原理，将子函数作为父函数的返回值,通过外部全局变量与子函数进行绑定，从而通过外部的全局变量可以间接操作子函数，实现对父函数局部变量在函数体外的访问，可以延长子函数的生命周期,父函数的局部变量的声明周期也同样被延长

目的：在父函数的函数体外,使用内部局部变量

作用：一般情况函数执行完里面声明的变量被垃圾回收处理掉，但是闭包可以让局部变量在函数执行完后依旧存在，不被垃圾回收处理掉

可以读取函数内部的变量

让变量的值始终保持在内存中

增加块级作用域

注意事项：因为闭包能使局部变量保存在内存中，消耗内存，会造成网页的性能问题，不可滥用闭包

闭包的缺陷:延长局部变量的生命周期,有可能会造成内存泄露		

闭包会在函数外部改变父函数内部变量的值，使用时不要随便改变父函数内部变量的值；

闭包不支持es6语法

function fun(){

​		var count = 0;

​		function fun1(){//子函数fun1可以使用父函数的count,让fun1作为fun的返回值,

​			console.log(++count);//通过全局变量f与fun函数的返回值fun1进行绑定

​		}              //从而实现了将内部函数fun1的生命周期延长，同样count的生命周期也被延长

​		return fun1;   //我们可以通过f函数来操作fun的内部局部变量count

​	}

var  f=fun();---------f=fun1,fun1是闭包，f接收返回的值，

5.函数对象：函数是个function类的对象，跟date,数组都一样

定义方式：* 函数声明 声明的方式有函数的提升

function test(ord){

 alert(“亲”+ord+“！”);

}

\* 函数表达式（匿名函数)

var test = function(ord){

 alert(“亲”+ord+“！”);

}

\* 对象的方式：

let test = new Function(实际参数1,参数2...,"函数体");

函数内置对象：函数体内直接使用的对象，有（ arguments和this），自动产生，不需要用函数名来调用

text();------调用

注意事项：既然定义一个函数就是创建一个函数对象， 那么只要执行函数定义的代码，就会创建新的函数对象，所以有的引用类型都必须new；

函数不是定义无效果，定义需要开辟空间，只是不调用则没效果

\* arguments对象保存函数的所有参数，虽然可以像数组一样的访问每个参数，不能使用API，是个伪数组，

函数体一样但函数名不同，两者不相同；

6.arguments.callee:等价于该函数自己本身（使用场景：递归）

递归：函数直接或间接的调用自己，简化代码

function fun(n){

​		let c;

​		if(n == 1){

​			c = 1;

​		}else{

​			c = arguments.callee(n-1)*n;

​		}

​		return c;

​	}

​	console.log(fun(10));

7.prototype(原型对象)：【只强调身为类的函数】是函数对象的一个属性，由于方法行为是属于整个类的，而不是某一个对象，所以方法应该只存在于一块空间，而不是每new一次创建一次并开辟空间造成空间浪费，我们将整个类族的方法，放置到一块空间里，提供给同一个构造函数的所有实例化对象访问，这个空间就是原型对象；

function Student(name,id){

​		this.name = name;

​		this.id = id;

}

Student.prototype.study = function(){

​		console.log(this.name + ":study");

​	}

let s = new Student("杨泽凯",1);

s.study();

注意：

当某个实例化对象修改原型属性时，等价于添加同名自定义属性，无法影响原型对象上的属性,

对于类而言，prototype保存着所有的实例方法，虽然平时是直接调用方法，但是正真保存在prototype中，我们创建的每个实例化对象都有一个属性_proto_，是个指针，指向构造函数的属性prototype，prototype空间里面包含所有实例共享的属性和方法，所有通过同一个构造函数创建的实例对象，都会共享同一个prototype	

区分原型属性与实例属性：用new调用构造函数创建出来的对象叫做实例

跟在prototype后面的属性叫原型属性

实例化对象如何访问自己的属性与方法：实例化对象的指针_proto_指向其所相对应类的原型对象，由类的原型对象指向原型对象空间，

8.apply与call[修改有名函数的this指向的方法],apply和call实现的功能是将类和成员函数进行解耦

function 方法名(){};

格式：方法名.call(修改的this指向,函数对象的参数1,参数2...)

​    	 方法名. apply(修改的this指向,[函数对象的参数1,参数2...]);

面试题

​	apply,call,bind有什么异同?

​	1.他们都是修改函数this的指向

​	2.apply的第二个参数是数组，

​	3.bind多用来修饰l针对匿名函数,apply和call针对修饰有名函数

​	4.apply和call修改函数this指向时，直接调用该方法，而bind方法则创建了一个新的函数对象,该函数对象需要重新调用

​	let fun = eat.bind(m,"人参果","金丹");

​	fun();

instanceof与typeof的异同点：

对象 instanceof 类：判断当前数据类型：返回boolean值，高版本兼容低版本

typeof能够检测出了null之外的内置基本类型（String、Number、Boolean、Undefined）,引用类型始终返回“object”

共同点：基本数据类型都可以判断

不同点：instanceof可以判断这个变量是否为某个函数的实例，而typeof不能

用法：typeof经常用来检测一个变量是不是最基本的数据类型，instanceof简单说就是判断一个引用类型的变量具体是不是某种类型的对象。

联系：typeof和instanceof的目的都是检测变量的类型，两个区别在于typeof只能用于检测基本数据类型，instanceof可以检测基本数据类型，也可以检测某些引用数据类型,但是instanceof只能通过true或者false来判断，不能直接看出来是什么类型。

9.深拷贝浅拷贝

内置基本类型和引用类型在内存存储的区别，内置基本类型只有一块栈空间,存储的就是数值本身，引用类型有两块空间,一块栈空间，存储的是new出来堆空间的地址，另一块堆空间,存储的是数值

只有引用类型有深浅拷贝的概念赋值永远赋的是栈空间的内容；

拷贝:用已有对象初始化一个新的对象

浅拷贝:只拷贝地址，但是并未开辟空间,两个变量共享同一个空间

深拷贝:开辟空间且赋值；

10.继承(es5)

1).原型继承：通过子类的原型对象，指向父类的某个实例化对象，则现原型继承[指向实例化对象则可以访问此对象的实例属性与他里面的原型对象]

原型继承的缺陷：

有父类派生给子类的属性，是无法在子类对象构造时初始化的

继承关系一定要写在子类添加原型方法之前，否则原型方法会被覆盖

原型关系一旦实现，则不可以被修改；

如果继承则继承全部

注意：子类的对象，如何访问到父类的属性和方法，及子类的属性和方法

2).多级继承：通俗的来说，爸爸类继承爷爷类，儿子类继承爸爸类，中间多一层儿子类的原型对象指向爸爸类的实例化对象；其中儿子类可以使用爸爸与爷爷的所有属性与方法；

3).call与apply的“继承”：解决了原型继承时子类对象无法在构造时初始化由父类派生的属性，其中，在构造子类时，需要将父类的形参当成形参写进去，然后借用父类构造方法.call(this,形参1，形参2)但是方法不能像原型继承一样继承

apply与call的继承是为了解决父类派生给子类的属性无法在构造时初始化的问题，因为原型继承中子类的原型对象指向的是父类的实例化对象，而之所以获得方法是因为方法存放在prototype里面，而实例化对象自带_proto_指针；

​	//缺陷：没有办法绑定原型对象上的属性或者方法

4)混合继承:里面既有原型继承也有call与apply的继承;

Person.call(this,name,id)//由于父类person实际上也是函数，将它当作方法调用call,这里的this代表Student,与构造方法连用，this代表new 出来的对象【es5中，类既是方法也是构造方法】

11.es6继承 ：

使用关键字extends让子元素继承父元素，子类里面需要传入父类的形参，借用父类的构造方法，super必须写在子类构造方法的首行

12.本地存储与会话存储

背景：cookies的大小限制在4kB，不适合大量的数据存储。

浏览器还限制站点可以在用户计算机上存储的cookies的数量。

cookies是随HTTP事务一起被发送的，因此会浪费一部分带宽。

HTML5很好的提供了本地存储的功能，以键值对存储的解决方案，支持容量至少为4M，HTML5的web提供了两种客户端存储方式。

localStorage：是一种没有时间限制的数据存储方式，可以将数据永久保存在客户端。

sessionStorage：指的是针对一个session的数据存储，即将数据保存在session对象中，当关闭浏览器后，这些数据就被删除。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。

属性：

getItem(key):获取指定key所存储的value值=====三种方法：打点，中括号，getItem

key(index)方法：返回列表中对应索引的key值

length属性：返回key/value队列的长度

removeItem(key)方法：从Storage中删除一个对应的键值对。

setItem(key,value)方法：将value存储到key指定的字段=======三种方法：打点，中括号，setltem

clear()方法：移除所有的内容

cookie\localStorage\sessionStorage三者的区别：

从数据的生命周期来说：cookie可设置失效时间，有会话cookie与长生命周期，localStorage除非被清除，否则一直存在，sessionStorage是只在当前会话中存在

从存放数据大小来说：cookie只有4kb,而后两者4~5mb;

从与服务器端通信时，cookie是每次携带在http头中，而后者保存在本地中

后者更好用，

共同点：都是保存在浏览器端、且同源的 

区别： 

1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 

2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 

3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 

4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 

5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 

6、web Storage的api接口使用更方便

13.设计模式(掌握)

背景:目前企业级分布式软件开发普遍采用面向对象的方法，00D(面向对象设计)导致了设计模式的发展；

使用设计模式的原因：增加复用性，减少设计的多样性，为设计者提供通用的语言，增强设计的可理解性；

定义：模式是在一个上下文中，对一个问题的解决方案。即模式的四要素：名字、上下文(坏境)、问题和解决方案。

1)单例模式：一个类只能有一个对象，只有第一次new出来的是创建的对象，后面new的则都是第一次创建的对象，这个类被称为单例类；

作用：在项目间更方便的传递数据，降低内存开销，只需要创建一个对象；

写法1：function King(name) {

​        if (King.unique == undefined) {

​            this.name = name;

​            King.unique = this;

​        } else {

​            return King.unique;

​        }

​    }

​    let k1 = new King("乾隆");弊端：king.unique会在外面被改变；

写法2：闭包实现

let singletion = (function(name) {

​        var unique;

​        function King(name) {

​            this.name = name;

​        }

​        if (unique == undefined) {

​            unique = new King(name);

​        }

​        return function() {

​            return unique;

​        }

​    }("康熙"));

​    let s1 = singletion();

2）观察者模式【发布订阅模式】：一个对象订阅另一个对象的特定活动并在其状态发生改变后获得通知，然后执行相应的操作。订阅者也称为观察者，而被观察的对象则被称为发布者或主题。当一个事件发生，发布者将会向所有订阅此事件的对象以事件对象的形式传递消息。【发布者、订阅者（观察者），发布者发送消息，订阅者订阅特定消息并接受发布者发送的消息。

】

//观察者(订阅者)客户端存在的函数

​    let sub1 = {

​        //描述函数定义

​        update: function(what) {

​            console.log("sub1" + what);

​        }

​    }

​    let sub2 = {

​        update: function(what) {

​            console.log("sub2" + what);

​        }

​    }

​    let sub3 = {

​        update: function(what) {

​            console.log("sub3" + what);

​        }

​    }

//发布者(主题)

​    class Dept {

​        //发布者一定知道自己的订阅者是谁

​        constructor(subs) {

​            this.subs = subs;

​        }

​        infor(what) {

​            for (let i = 0; i < this.subs.length; i++) {

​                //发布者调用约定好的函数且传递信息

​                this.subs[i].update(what);

​            }

​        }

​    }

​    let d = new Dept([sub1, sub2, sub3]);

​    d.infor("起床尿尿");

3)工厂模式：根据不同场景生产不同的对象；

function Factory(role) {

​        function Student() {

​            this.view = ["测评", "考试", "请假"];

​        }

​        function Teacher() {

​            this.view = ["出题", "批阅", "批假"];

​        }

​        function boss() {

​            this.view = ["为所欲为"];

​        }

​        switch (role) {

​            case "stu":

​                return new Student();

​            case "teacher":

​                return new Teacher();

​            case "boss":

​                return new boss();

​        }

​    }

​    let stu = Factory("stu");

​    let teacher = Factory("teacher");

​    let boss = Factory("boss");

​    console.log(stu, teacher, boss)//输出结果是：相对应的三大类

**九.插件**

1.概念

   插件是一个独立的功能，与函数相比，他是更加完整的功能，假设将一个汽车比作项目 函数好比汽车的螺丝，螺帽。而插件就好比发动机，变速箱。

2.设计：设计者

1.提供插件      

2.提供使用说明(API帮助文档)

3.使用(一般web前端)：使用者 ===》

1.引入插件用script里面的src属性引进

2.提供插口[css样式，html元素，script标签里面的东西]  

​      3.遵循帮助文档使用插件

**十.jQuery**

1.JavaScript和查询，即是辅助JavaScript开发的库；是一个快速的简洁的JavaScript框架，可以简化查询dom对象，处理事件，制作动画，处理ajax交互过程

2.特点：提供强大的功能函数，解决浏览器兼容性问题，纠正错误的脚本知识，体积小，只需要引入一个js文件，易扩展，插件丰富

3.作用：

程序员角度：简化js与ajax编程，让程序员将关注点转向功能需求而非实现细节，从而提高项目的开发速度

用户角度：改善页面视觉效果，增强页面的交互效果，体验更绚丽的网页物资，方便的选择页面元素(模仿css选择器更精确，更灵活)，动态更改页面样式/页面内容(操作dom，动态添加，移除样式)，控制响应事件，提供基本网页特效(提供已封装的网页特效方法)，快速实现通信(ajax)

4.引入jQuery的方式：

​              

【必须联网】

​              

5.jQuery()是一个核心函数，可以传各种各样的参数，jQuery(function(){ })类似于window.onload=function(){}，function里面之间的内容是一样的，只不过一个是源生，一个是jquery;

7.$()===jquery(),$()相当与页面初始化函数，当页面加载完毕，会执行$(),即jQuery.

8.jQuery()与延迟加载函数window.onload的区别：

onload是指包含图片在内的所有元素都加载完成，而$()是指文档已加载完成，不包含图片等非文字媒体文件,

9.$(function(){})是简写，完全体为$(document).ready(function(){};其中，ready要优先于onload

10.原生js与jQuery完全是两套语法,尤其要关注HTML元素;

11.jQuery读取元素:例如读取里面的容:$("#box").html();//html()===innerHTML;

12.源生dom对象,分为单独的一个元素或者多个元素,多的元素放在一个数组里

,jQuerydom对象,无论几个元素,都放在包装集里面;

13.两种对象的相互转化

源生转jQuery：

let oBox=document.querySelector("#box");

​	   $(原生dom对象),即$(oBox);  

jQuery转源生：

$("#oBox").get(0)||$(obox)[0]://两种方式，将包装集中下标为0的jQuery对象对应的原生对象返回，

14.jQuery选择器

基础选择器:

​	1.id选择器:$("#box1")

​		修改样式:$("#box1").css("backgroundColor","red");

​				$("#box1").css({

​					backgroundColor:"red",

​					color:"yellow"

​					});

​	2.类选择器:$(".box1").css({

​		样式修改

​	})

​	3.标签选择器:

​	$("p").css({

​		样式修改

​	})

​	4.群组选择器

​	$("p,span,div").css({

​		样式修改

​	})

​	5.通用选择器:

​	$("*").css({

​		样式修改

​	})

6.层次选择器:后代选择器,

​	$("body div").css({

​		样式修改

​	})

​	子代选择器,

​	$("body>div").css({

​		样式修改

​	})

​	兄弟选择器,

​	$("body~div").css({

​		样式修改

​	})

​	相邻选择器

​	$("body+div").css({

​		样式修改

​	})

属性选择器:

​	1.通过属性名来选择器:

​	$("div[class]").css({修改样式});

​	2.通过属性值来选择

​	$("div[id="box1"]").css({....});

​	3.通过多个属性来选择

​	$("div[id][class]").css({...});

伪类选择器:

​	1.even:获取偶数元素

​	$("div:even").css({...})

​	2.odd:获取奇数元素

​	$("div:odd").css({...});

​	3.first:获取第一个元素

​	$("div:first").css({...});

​	4.last:最后一个元素

​	$("div:last").css({...});

​	5.eq(n):获取下标所对应的元素;从0开始

​	$("div:eq(n)").css({});

​	$("div").eq(n).css({})

​	6.not(目标元素)除了某个元素都选:

​	$("div:not("#box2")").css({..});

​	$("div").not("#box2").css({..})

​	7.lt(n):选中小于n的元素,但是包含n,

​	$("div:lt(3)").css({});

​	8.gt(n):选中大于3的元素,

​	$("div:gt(3)").css({})

内容选择器:

​	1.contains(内容):根据元素的内容来查找

​	$("div:contains('...')").css({});

​	2.empty:找内容为空的元素

​	$("div:empty").css({...})

​	3.根据子元素来查找:has(子元素)

​	$("div:has(#s)").css({});

根据可见性选择器:

​	1.hidden:隐藏

​	$("tr:hidden").css({});

​	2.visible:显示;

​	$("div:visible").css({})

15.遍历：

​	a:兄弟间的遍历:

​		1.next():下一个元素,特点:连缀模式,

​		$("#box2").next().css({});

​		2.nextAll():下一堆兄弟元素

​		$("#box2").nextAll().css({});

​		3.prev():上一个元素

​		$("#box2").prev().css({});

​		4.prevAll():上一堆元素

​		$("#box2").preAll().css({});

​	b父子之间的遍历

​		1.父元素.find("后代元素"):查找后代元素,必须得有元素,不写无效果

​			$("body").find("p").css({..});

​		2.父元素.children([子元素]);查找子元素,

​			$("#box2").children([]).css({});不写则代表所有子元素

​		3.parent():找父元素

​			$("p").eq(2).parent().css({})

siblings("li")：分为有参无参，无参代表我当前平级的所有兄弟元素，有参代表目前li的兄弟

4.parents();找元素所有的祖宗节点

16.//文本:有参为写无参为读

​	1.value==val();

​	读：console.log($("input").val());

​	写:   console.log($("input").val("哈哈"));

​	2.innerHTML==html();

​	读:console.log($("div").html());

​	写console.log($("div").html("哈哈"));

​	3.字符串的拼接：let str=" "---> str+=" "--->$("div").html(str);

17.jquery动画：

​	1.基本动画：固定的；

​			a:jQuerydom.hide([speed],[easing],[fn]),隐藏动画,如果获得的元素是隐藏的,则不会有任何效果(存在异步)

​			$("#box").hide([2000],[linear],[fn])

​			speed:执行时间毫秒

​			easing:用来指定切换效果,默认是:swing,可用参数是linear;

​			fn:回调函数是异步代码,执行完之后执行的代码,在动画完成时执行的函数,每个元素执行一次;

​		b:jQuerydom.show([speed],[easing],[fn]):动画队列:如果启动多次,因为要消耗时间,所以等待前一次执行完执行后一次;

​		c.jQuerydom.toggle([speed],[easing],[fn]):切换,(取反);若回调函数是自己本身,则会递归

​	 2.滑块动画

​				jQuerydom.slideUp([speed],[easing],[fn]):滑上消失

​				jQuerydom.slideDown([speed],[easing],[fn]);滑下出现

​				jQuerydom.slideToggle([speed],[easing],[fn]):切换

​	3.淡入淡出:

​	jQuerydom.fadeIn([speed],[easing],[fn]);淡入,显示

​	 jQuerydom.fadeOut([speed],[easing],[fn]);淡出,消失

​	 jQuerydom.fadeToggle([speed],[easing],[fn]);

​	4.自定义动画

​	1.jQuerydom.animate({},2,3,4)

​	 jQuerydom.animate({

​		 width:50||width:"50px",//不可改变颜色，要么字符串要么数字

​	 },[speed],[easing],[fn]).animate({})....;//可以加多个动画效果

​	2.jQuerydom.stop(false,false);//立刻结束当前动画，执行后面的动画序列，无参就是两个false；

事件：dom.click([传递给回调函数的参数]，回调函数function(evt){

​	evt.data.参数名

})

18.jQuery的ajax：高层越偏向于用户，低层越偏向于计算机

1.$.get()

$.get(url,[data,callback(resText,status,xhr){}]);(jquery对象,方法里面没有使用this静态，拿类名打点直接调用)；返回值为promise对象

url：路径，文件地址；

data:数据，可以是键值对，json对象；

callback:回调函数；其中resText代表返回值，可以是xml文档，json对象字符串，status代表状态成功或失败;成功了才调用回调函数；

例如;$.get(url,data).then(function(){resText,status，xhr});

2.$.post();

3.get与post的区别：

1.post的安全性高于get,如果以get方式请求，请求参数会拼接到url后面，安全性低，以post请求，请求参数会包裹在请求体中，安全性更高

2.数量区别：post方式请求数据量大，没有限制，get方式传输的数据量小，规定不能超过2kb

3.传输速度：get高于post;

4.因为使用方法相同，因此只要改变jQuery函数，就可以将程序在get请求和post请求之间切换。

4.load(url,[data],[callback])页面头尾引入，提高复用性

功能：载入远程html文件代码并插入至dom中，默认使用get方式

参数：url：待装入的HTML网页,url后面可以跟标签，代表引入标签对应的内容，不加则代表整个文件；

data:发送至服务器的keyvalue数据；

callback:载入成功时回调函数；

返回值：返回响应添加至dom元素的html();

举例：

$("#box").load("head.html");则会将head.html中的内容添加到dom元素里，url的内容可以放置css,js，html，

传递方式：

load()通常是从web服务器上获取静态的数据文件，如果需要传送一些参数给服务器中的页面，可以使用$.get()方法与$.post()、$.ajax(),

load()方法传递方式根据参数data来自动指定，

不加请求参数为get方式

加请求参数是post，传递附加参数时自动转换为post方式

5.$.getScript()方法与$.JSON()方法

功能：在需要js文件的时候直接加载，不需要对js文件进行处理，js文件会自动执行(之前是用src属性将js引入，现在是用$.getScript引入小件js代码)

参数：$.getScript(url请求地址,fn回调函数)；

举例：$("button").click(function(){

​		$.getScript("url",function(){

​			调用功能模块;

​		})；

​	})；

$.getJSON(url,请求参数,回调函数)

​	作用：获取数据,通过该方法得到的结果直接就是json对象,不是json字符串;

​	$.getJSON("getjson.json",function(data) {

​	    // console.log(data);

​	    for (let i = 0; i < data.length; i++) {

​	        console.log(data[i].name, data[i].id);

​	    }

​	});

6.$.ajax():

功能：前面的五种方法都是基于$.ajax()实现的，他是jQuery最底层的ajax实现，因此它不仅可以实现与前面方法同样的功能，而且还可以设定beforeSend(提交前回调函数)、error(请求失败后处理)、success(请求成功后处理)、complete(请求完成后处理)回调函数，通过设定这些回调函数，可以给用户更多的ajax提示信息，还有一些参数可以设置Ajax请求的超时时间或者页面的“最后更改”状态

参数：$.ajax({url,type,data,【datatype】,success});

参数解析：url:请求地址；

type:get||post||put||delete,默认get;

data:请求参数{"1":"123","2":"3"};

datatype:请求数据类型 html||text||json||xml||script||jsonp;

success:function(data,dataTextStatus,jqxhr){};请求成功

function(jqxhr,TextStatus,error)：请求失败

举例：$.ajax({

​		url:"get.php",

​		type:"get",

​		data:{

​			userName:"老王",

​			content:"老王的隔壁是老王"

​		},

​		success:function(resText){

​			console.log(resText);

​		}

​	})

19.jqueryDom的api:

1.属性的读写::有参为读无参为写

读:attr("属性名")

​	$("#box").attr("id");等价与源生dom.getAttribute("属性")

写:attr("属性名","属性值")

​	$("#box").attr("id","属性值");

和checked有关的用prop;

​	

​	此时$("input[type=radio]").attr("checked")==true时为false;

​	此时$("input[type=radio]").attr("checked")==checked时为true;,当input里面不写checked属性时为undefined结果为true;

​	此时$("input[type=radio]").prop("checked")==true时为true;

2.样式的读写;//读出来的是字符串

读:$("#box").css("width");||$("#box").css(["width","height","background"])

写:$("#box").css({width:300});

3.offset相关的读写//读出来的是数字

​	宽,高

读:$("#box").width();content的宽,高

$("#box").outerWidth();content的宽+border+padding;

$("#box").innerWidth();content的宽+padding;

写:$("#box").width(500);

4.left,top

写:$("#box").offset({left:200,top:200//不用写源生里需要的position自带绝对定位})

读:$("#box").offset().left//读出来的时数字

滚动条的高度:源生需要兼容,jQuery不需要

​	window.onscroll=function(){

​		console.log($(window).scrollTop());//有参为写，无参为读

​	}

​	案例:$("button").offset({

​		top:1000}).click(function(){$(window).scrollTop(0)})

5.index():当点击li时自带下标属性从0开始    $("li").click(function{$("this").index();})							

20.dom节点的增删：

1.节点的增:

创建:let oDiv=$("");//	携带内容创建:let oDiv=$("hhhhh");追加	尾插:		1.$("父元素").append(创建的新元素);		2.创建的新元素.appendTo($("父元素"));	头插:		1.$("父元素").prepend(创建的新元素);		2.创建的新元素.prependTo($("父元素"));	将目标元素插入至参照元素之前		1.参照元素.before(目标元素);		2.参照元素.insertBefore(目标元素);	将目标元素插入至参照元素之后		1.参照元素.after(目标元素);		2.参照元素.insertAfter(目标元素);2.节点的删:与源生一样remove():节点.remove();//将房子连同内容一起删empty():节点.empty();//等价于html("");内容删掉房子留着21.懒加载1.概念:访问页面时,若有多张图片,先显示可视区域的图片,不会一次性加载所有图片,当需要显示后面的图片在发送图片请求,避免打开网页时加载过多资源,是一种网页性能优化的方式2.原理:图片有一个src属性,用来放置图片的url,如果没有src,浏览器则不会发送图片的请求,所以自定义一个img的属性用来放置图片的url,先不设置src,在当那张图片进入可视区域时,将url赋值给src;3.利用知识点:图片距离顶部的高度:img.offsetTop;	当前窗口的高度:innerHeight;	滚动条的高度:var top=document.scrollTop||document.documentElement.scrollTop;	图片在可视区域:img.offsetTop22.jQuery插件1.jQuery插件添加有两种形式a.全局添加，也就是为$添加属性或者方法举例：$.i=123;b.为jQueryDom元素添加方法举例：$("div").heihei();2.为$添加属性或者方法a:通过打.的方式添加自定义属性(插件)$.fun=function(){console.log("......")}$.fun();b.extend:jQuery提供的添加插件的一个方法$.extend({a:123,sayHello:function(){console.log(".......")}});//作用等价与a方法$.sayHello();23.为jqueryDom对象添加方法$.fn.extend({change:function(w,h,color){$(this).css({width:w,height:h,backgroundColor:color})}})$("box").change(100,200,"red");24.引入第三方插件（script的src）；二.nodeJS1.运行js的是浏览器里面的js引擎,其中，ECMAscript语言提供语法，bom，dom是浏览器提供的，因此，编程语言的能力是由执行环境决定的，对于js来说，浏览器只是一个平台，因此要像语言有强大的能力，需要提供强大的平台。2.js的作用：操作dom，发送Ajax请求/跨域，bom交互(提供页面跳转，历史记录，控制台打印日志)，ECMAscript(用来定义变量，函数)，3.局限：涉及到端对端的应用程序，需要操作文件，浏览器中的js不能进行文件操作，无法操作操作系统4.node.js是一个用拥有谷歌v8引擎的js运行环境+大量的新API,使用nodejs来编写服务端代码(，一个让js运行在服务端的开发平台，可以理解为运行js的一个虚拟机，将js的运行环境由浏览器搬到了服务器，node里面分为两部分，引擎(执行语言)，工具库(帮助node实现各种功能)比如文件操作，网络操作，操作系统的操作，node与nodejs)，node.js之间没有区别，node的全称就是nodejs，node.js与JavaScript的区别：1、node.js是平台，Js是编程语言；2、js是客户端编程语言，需要浏览器的JavaScript解释器进行解释执行(前端的js)3、node.js是一个基于Chrome JavaScript运行时建立的平台，它是对Google V8引擎进行了封装的运行环境（后端的js）4、node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似JavaScript的结构语法进行编程，在node.js上运行5.node.js搭建服务器的好处：前端人员熟悉js语法，效率非常高，是普通服务器的10倍，敏捷开发6.通过node搭建自己的服务器语法:const http=require('http');与new http()等价，创建服务器的方法客户通过网址访问，实质就是在运行createSever里面的回调函数返回值为服务器对象http.createServer(function(req,res){	响应可以提供中文编码格式	res.writeHead(200,{"content-type":"text/html;charset=utf-8"});	res.end(返回给用户的内容);	res.end("嘿嘿")}).listen(8888);设置该服务器的端口号7.运行：在外部资源管理器打开，并在地址栏里使用cmd,在终端上使用node+空格+文件名，最终在浏览器里使用IP地址+端口号8.模块：原先:程序=对象+对象node里:程序=模块+模块:模块化编程对象===模块const http=require('http.js');里面的http.js类似于:data,string,array,但是是模块不是类,而是文件,打点都可以调用里面的东西；9.js文件可以相互引入，所有的js文件就都是模块10.模块分为三类：内置模块:node平台自带的 自定义模块:自己写的js文件 第三方模块:从官网的appStore下载的别人的11.CommonJS:提供了js文件导入和导出的标准语法,(后端)12.导入模块:原因：引入别的文件的文件需要设置导入语法：require导入模块的规则:require("模块名称");12.导出模块:原因：引入的文件需要设置导出;凡是放在这个语法里面的内容才可以被访问到语法导出1.:module.exports={花括号里面是json内容,=右边的相当于json对象；		a:6666,		fun:function(){console.log("...")},		fun(){导出规则支持ES6的函数写法；		console.log("haha")}}语法导出2:通过添加自定义属性的方法暴露:exports.自定义属性名=定义过的变量;例如:let b=123;exports.b=b;将b的值放在暴露模块里;两者都为暴露规则,更推荐前者;后者不可以使用json;后者是前者的浅拷贝模块的组合：module.exports={key1:const的模块名字，支持es6}13.注意：const用不用无所谓,let也可以,但是const不改变例如:const common=require("./nodeb.js");变量名随便,引的文件的后缀可以省略,但是./不可以省略,如果设置一个目录为node_modules,将模块放在里面,不管任何路径,都不需要设置./;14.const http=require('http.js');这个里面的http模块为内置模块,导入模块之后,js里面的文件内容就可以正常打点调用;15.前端es6导入导出(提高代码复用性),前端的模块化,方法1.在html页面里面使用js src属性引入b.js文件,添加属性type=module，b.js文件里使用a.js文件的内容则在b.js文件里使用：import{导入的属性1,,,导入的属性n}from "./a.js(文件名)";导入之后b.js文件就可以直接使用导入的属性了，前提是需要将被导入的属性在a.js里面暴露，使用语法export直接修饰，：export 对象（export let a=666）方法2：暴露：export default{key1,key2}导入：import 变量名 from "./文件名"变量名打点调用16.包与NPM:1.包：nodejs中第三方模块由包组成，可以通过包来对一组具有相互依赖关系的模块进行统一管理，2.npm：包管理工具，用来下载第三方模块，（打开软件市场命令，node平台一起安装自带的）安装第三方模块：在终端使用命令：npm install silly-datetime+回车：下载引入：const sd=require("silly-datetime");let date=new Date();console.log(sd.format(date,"YYYY-MM-DD hh:mm"));按照格式格式化17.npm的使用场景：允许用户从npm服务器下载别人编写的第三方包到本地使用；允许用户从npm服务器下载并安装别人编写的命令 行程序到本地使用；允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用18：有关npm命令:npm -v:查看npm版本；使用npm命令安装模块：npm install ModuleName:安装ModuleName模块npm uninstall ModuleName:卸载模块npm list:查看当前目录下已安装的node包npm info 模块名称 :查看某个包的详细信息19.node的自动重启工具：nodemon使用原因：编写调试node.js项目时，修改代码后，需要频繁的手动close掉，然后重新启动，现在使用这个工具，他的作用时监听代码文件的变动，当代码改变之后，自动重启；使用步骤：npm install -g nodemon安装好直接使用：nodemon 文件名.js;20.fs模块（fileSystem）：针对于文件内容的读写(内置模块）功能：用来操作文件数据的读写使用步骤：1.const fs=require("fs")：2.fs.readFile("路径"，function(err，data){}):读取文件（异步操作）**是否失败:读取失败：则创建错误对象****文件内容：成功则执行data,读到的内容为数据流，需要data.toString();转化为字符串；**3.fs.writeFile("路径"，往里写的内容，{flag:"w/a"追加/覆盖}，function(){})：写文件;写文件本身是文件的替换；如果原文件不存在则会创建新的同名文件且添加内容；写文件本身是文件的替换；如果原文件存在，不设置{flag:"w/a"}/{flag:"w"}，则覆盖，若是设置{flag:"a"}，则追加在原文后面注意：读写都是异步操作5.fs.mkdir(“文件夹名”，function(){}):创建一个目录，回调函数必须存在；6.fs.rmdir(“文件夹名”，function(){}):删除一个文件夹;7.fs.unlink("路径"，function(){}):删除一个文件21.路由：是一个由url和一个特定的http方法(get/post)组成的，涉及到应用如何响应客户端对某个网站节点的访问(路由指的是针对不同请求的url，处理不同的业务逻辑)req.url:获取的是请求 的参数(就是端口号后面从/开始的参数)；22.gulp：是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器，不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成,提高我们的工作效率，(简单且重复性操作的工具，是基于nodejs的自动任务运行器，可自动化的完成文件的测试检查合并，拷贝，压缩(js,图片，css)，格式化，浏览器自动刷新，部署文件生成，并监听文件在改动后重复指定的这些步骤)；处理复杂的业务逻辑，并不是解决低级且重复的工作可以是实现文件的测试检查合并，拷贝，压缩(js,图片，css)，23.cnpm与配置环境变量cnpm:npm的服务器是在国外,下载慢,安装cnpm,从cnpm下载东西,速度快,	安装1.在cmd命令行上执行:npm install cnpm -g --registry=https://registry.npm.taobao.org	作用:从npm上下载cnpm从数据源里面,配置环境变量:步骤:打开程序所在文件夹的位置,回退到bin目录复制到设置环变量里面的系统设置中的path,添加作用:配置了则任何磁盘都可以执行node文件,否则只能在安装了node软件的文件夹里使用24.cnpm与配置环境变量cnpm:npm的服务器是在国外,下载慢,安装cnpm,从cnpm下载东西,速度快,	安装1.在cmd命令行上执行:npm install cnpm -g --registry=https://registry.npm.taobao.org			作用:从npm上下载cnpm从数据源里面,配置环境变量:步骤:打开程序所在文件夹的位置,回退到bin目录复制到设置环变量里面的系统设置中的path,添加作用:配置了则任何磁盘都可以执行node文件,否则只能在安装了node软件的文件夹里使用25.gulp在项目中的使用: gulp的介绍    程序员工作:处理复杂的业务逻辑，并不是解决低级且重复性的工作。    项目的自动构建化工具完成.gulp就是这样的工具,    它可以实现,文件的拷贝,压缩（js、图片、css）,合并，将ES6的代码转换为ES5的代码等。      gulp的环境安装   	安装cnpm 	   npm install cnpm --registry=https://registry.npm.taobao.org  -g   (-g指全局，为了配置环境变量    为什么要配置环境变量,保证当前安装的exe程序可以再磁盘的任意位置使用。)    		   找到当前exe所在的路径 		   C:\Program Files\nodejs  		  此电脑->属性->高级系统设置->高级->环境变量->系统变量->Path   	2. 安装gulp软件 ：cnpm install gulp -g   3. gulp的使用步骤    			1.项目根目录下    					cnpm init， 创建初始化文件 package.json    			2.安装gulp模块   					 cnpm install gulp --save-dev   						 --save-dev 开发依赖    						--save     生产依赖    			3.在根目录下创建gulpfile.js文件gulp的api:	gulp.task("任务名称",function(){执行任务执行的代码}):任务定义	gulp.src("要操作的文件路径(文件源)").pipe(gulp.dest()//里面包的除了src的以外gulp的函数)	文件夹/**/*:将文件夹下所有的内容都进行拷贝	gulp.dest(文件拷贝的位置):	gulp.watch("被监听的文件名",function(){}):监听,只要这个文件发生改变就执行回调函数(淘汰)    gulp插件  	  合并  cnpm install gulp-concat --save-dev   	 压缩js：cnpm install gulp-uglify --save-dev   文件重命名：  cnpm install gulp-rename --save-dev       压缩css:cnpm install gulp-minify-css --save-dev    压缩图片cnpm install gulp-imagemin@7.1.0 --save-deves5-ES6    cnpm install --save-dev babel-preset-es2015    cnpm install --save-dev gulp-babel@7 babel-core babel-preset-envSASS一.基本概念1.SASS:css不是一个编程语言,可以用来开发网页样式,但是无法进行编程,SASS可以让css实现通过代码编程来实现的方式,所以SASS是一种css开发工具,让css实现可编程模式,SASS扩展了css3,增加了规则,变量,混合,选择器,继承等特性,可以生成css样式表文件,易于组织和维护2.SASS的安装:SASS基于Ruby语言开发而成,因此SASS的安装需要安装Ruby3.sass文件就是普通的文本文件，里面可以直接使用css语法，文件后缀名是.scss;在scss文件里面写@charset "utf-8",是为了写中文注释；4.将.scss文件转化成css文件：sass sass文件名：css文件名例如:文件名为test：命令实现：sass test.scss:test.css5.生成的css文件有四种格式：nested：嵌套缩进的css代码，是默认值expanded：没有缩进的扩展的代码compact：简洁格式的css代码compressed：压缩后的css代码6.--style属性可以指定生成的css文件是哪种格式：命令：sass --style compressed test.scss:test.css7.让SASS监听文件或目录，当源文件有变动的时候，自动生成编译后的版本监听文件命令：sass --watch test.scss:test.css监听文件夹命令:sass --watch css(文件夹名):css(文件夹名)二.基本语法：1.变量的定义:sass的变量赋值是单纯的文本替换	a:普通变量:		用$定义:例如:$color:yellow;		使用后:backgroundcolor:$color;	b.特殊变量:引入时#{};		例如:$prop:size			font-#{$prop}:26px;等价于font-size	c.默认变量:默认颜色是blue,修改则当无事发生,为修改后的值		例如:$color:blue !default;2.计算功能:	例如:width:10*10px||10px*10:等价于100px;3.嵌套:例如:#box{width:100px;		a{font-size:14px;			&:hover{				text-decoration:underline;}}}	等价于:先设置box,在设置了box里面的a,再划过a设置样式	4.高级语法	a.函数的定义:		定义函数:例如:$fontSize:10px;			@function pxTorem($px){				@return $px*$fontSize;			}		调用函数:			#box{				width:pxTorem(20);			}	b.if条件语句		$type:ocean;		#box{			width:100px;			height:100px;			@if $type==ocean{				background:blue;			}@else if $type==matador{				background:red;			}@else if $type==monster{				background:green;			}@else{				background:black;			}		}	d.循环:		for循环有两种形式			$var:表示变量			$start:表示开始值			end:表示结束值			形式1:@for $var from  through 			形式2:@for $var from  to 			两种形式的区别:through包括end的值,to不包括			例如:@for $i from 1 to 4{				.item-#{$i}{					width:$i*2em				}			}-----结果:生成三个类样式-1-2-3;		while			$i:2;			@while $i>0{				.item-#{$i}{					width:2em*$i;				}				$i:$i-1;			}	e.混合(mixin):对部分样式的定义及调用		@mixin 混合名称(参数列表){样式体}		定义:@mixin opacity($opacity:50//50是默认值，){			opacity:$opacity/100;			filter:alpha(opacity=$opacity)		}		使用:box{			@include opacity();		}三.版本管理工具1.概念:是一个内容管理工具，可以将项目的内容信息存放在版本管理服务器上方便项目组人员进行访问与修改2.版本管理主要有三个阶段：cvs----svn-Git3.git:前面两个阶段都是基于服务器的，如果脱离，则项目保存不了，git是一个分布式的版本控制系统，在git中，即使用户离线，也能进行项目的提交和更新，等连接到服务器时进行整体的同步操作，4.git是一个开源的分布式版本控制系统，用于敏捷高校的处理任何项目的版本问题是为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件git与前两者不同，采用了分布式版本库的方式，不必服务器端软件支持5.git的操作流程文件上传步骤：	在桌面上单击git bash here，输入name与email,	git config --global user.name xiaofu	 git config --global user.email 2482549641@qq.com	git init:进入项目目录再单击git bash here  创建本地仓库,	git add 文件名:添加至缓冲区	git log:显示日志，在本地仓库里有那个版本	git reset HEAD:从内存缓冲区撤销	git commit -m2.v,从内存缓冲区提交到本地仓库	git reset --hard 版本号（版本号在git log/git reflog的时候有一串橘色的）:切换版本号	本地操作完成之后,需要同步到远程服务器时,先上传到远程仓库	 1.ssh-keygen -t rsa -C 2482549641@qq.com:找到公钥，在用户名的设置中有ssh公钥设置公钥	 2.创建远程仓库：点击➕新建仓库，开源，点击创建，就好了	 3.点击ssh，复制，执行：git push -u origin(将origin换成复制的东西) master	 下载：克隆/下载键，复制出来的东西	 然后找到你想要放置文件的文件夹，进去单机git bush here,执行：git clone 复制的东西，就好了分支合并:	创建分支:git branch 分支名	git branch :查看当前有几个分支,	git checkout 分支名:切换到那个分支,切换到分支之后进行的操作都是基于分支	git merge dev:将dev合并到主分支之上;	删除分支:git branch -d dev**注意：**1.numeric(a,b)a代表整数位加小数位的总位数（不算），b代表小数位的位数。2.php文件中sql语句中的字符串用单引号括起来；3.php中的换行符得用双引号括起来；4.oninput:只要键盘输入就触发的事件position向上向左为正，left与top向下向右为正5.onchange:当里面 的内容发生变化时才会触发事件6.script src:发送请求，跨域访问7.函数定义也是要开辟空间的8.一般情况下从其他文件获取的内容是字符串9.console.log();当里面内容用双引号括起来时为字符串，不括时为数字；10.函数里的东西需要打印出来，不打印没有东西，return 是返回值，与打印没关系；需要调用11.instance of一般在继承使用,类型兼容性规则,高的包含低的,低的不包含高的12.super可以看成constructor13 客户端与浏览器端：客户端是指用户端，各种软件app，建立在局域网，而浏览器端建立在广域网,其实浏览器也是一种客户端，客户端可以是浏览器，但浏览器不能是客户端14.json:JSON 是存储和交换文本信息的语法在开发过程中，经常需要和别的系统交换数据，数据交换的格式有XML、JSON等JSON可以有两种格式**一种是对象格式的：**{"name":"JSON","address":"北京市西城区","age":25}//JSON的对象格式的字符串**另一种是数组对象**[{"name":"JSON","address":"北京市西城区","age":25}]//数据对象格式从上面的两种格式可以看出对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了[]，再来看具体的结构，可以看出都是以键值对的形式出现的，中间以英文状态下的逗号（,）分隔。在前端和后端进行数据传输的时候这种格式也是很受欢迎的，后端返回json格式的字符串，前台使用js中的JSON.parse()方法把JSON字符串解析为json对象，然后进行遍历，供前端使用。